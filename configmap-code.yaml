apiVersion: v1
kind: ConfigMap
metadata:
  name: polymarket-arb-code
  namespace: default
data:
  arb_bot.py: |
    #!/usr/bin/env python3
    """
    Polymarket Arbitrage Bot

    Monitors binary markets for pricing inefficiencies where YES + NO < $1.00
    and executes risk-free arbitrage by buying both sides.
    """

    import os
    import time
    import logging
    from datetime import datetime
    from typing import Optional
    from dataclasses import dataclass

    from py_clob_client.client import ClobClient
    from py_clob_client.clob_types import OrderArgs, BookParams
    from py_clob_client.order_builder.constants import BUY
    import requests

    # Setup logging
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s [%(levelname)s] %(message)s'
    )
    logger = logging.getLogger(__name__)

    # Configuration
    CLOB_HOST = "https://clob.polymarket.com"
    GAMMA_HOST = "https://gamma-api.polymarket.com"
    CHAIN_ID = 137  # Polygon

    # Thresholds
    MIN_SPREAD = float(os.getenv("MIN_SPREAD", "0.02"))
    MAX_POSITION_SIZE = float(os.getenv("MAX_POSITION_SIZE", "100"))
    POLL_INTERVAL = float(os.getenv("POLL_INTERVAL", "1.0"))

    # Credentials
    PRIVATE_KEY = os.getenv("POLYMARKET_PRIVATE_KEY")
    FUNDER_ADDRESS = os.getenv("POLYMARKET_FUNDER_ADDRESS")
    DRY_RUN = os.getenv("DRY_RUN", "true").lower() == "true"


    @dataclass
    class ArbOpportunity:
        market_id: str
        market_name: str
        yes_token_id: str
        no_token_id: str
        yes_ask: float
        no_ask: float
        total_cost: float
        profit_per_share: float
        timestamp: datetime


    class PolymarketArbBot:
        def __init__(self):
            self.client: Optional[ClobClient] = None
            self.opportunities_found = 0
            self.total_profit = 0.0
            
            if not DRY_RUN:
                if not PRIVATE_KEY or not FUNDER_ADDRESS:
                    raise ValueError("Credentials required for live trading")
                
                self.client = ClobClient(
                    CLOB_HOST,
                    key=PRIVATE_KEY,
                    chain_id=CHAIN_ID,
                    signature_type=1,
                    funder=FUNDER_ADDRESS
                )
                self.client.set_api_creds(self.client.create_or_derive_api_creds())
                logger.info("Initialized authenticated CLOB client")
            else:
                self.client = ClobClient(CLOB_HOST)
                logger.info("Running in DRY RUN mode (read-only)")

        def get_active_markets(self, tag: Optional[str] = None) -> list:
            params = {"active": "true", "closed": "false", "limit": 100}
            if tag:
                params["tag"] = tag
                
            try:
                resp = requests.get(f"{GAMMA_HOST}/markets", params=params, timeout=10)
                resp.raise_for_status()
                markets = resp.json()
                binary_markets = [m for m in markets if len(m.get("tokens", [])) == 2]
                logger.info(f"Found {len(binary_markets)} active binary markets")
                return binary_markets
            except Exception as e:
                logger.error(f"Failed to fetch markets: {e}")
                return []

        def check_arbitrage(self, market: dict) -> Optional[ArbOpportunity]:
            tokens = market.get("tokens", [])
            if len(tokens) != 2:
                return None
                
            try:
                yes_token = tokens[0]
                no_token = tokens[1]
                
                yes_book = self.client.get_order_book(yes_token["token_id"])
                no_book = self.client.get_order_book(no_token["token_id"])
                
                yes_asks = yes_book.asks if hasattr(yes_book, 'asks') else []
                no_asks = no_book.asks if hasattr(no_book, 'asks') else []
                
                if not yes_asks or not no_asks:
                    return None
                    
                yes_ask = float(yes_asks[0].price)
                no_ask = float(no_asks[0].price)
                total_cost = yes_ask + no_ask
                
                if total_cost < (1.0 - MIN_SPREAD):
                    profit = 1.0 - total_cost
                    return ArbOpportunity(
                        market_id=market.get("condition_id", ""),
                        market_name=market.get("question", "Unknown"),
                        yes_token_id=yes_token["token_id"],
                        no_token_id=no_token["token_id"],
                        yes_ask=yes_ask,
                        no_ask=no_ask,
                        total_cost=total_cost,
                        profit_per_share=profit,
                        timestamp=datetime.now()
                    )
            except Exception as e:
                logger.debug(f"Error checking market: {e}")
                
            return None

        def execute_arbitrage(self, opp: ArbOpportunity) -> bool:
            if DRY_RUN:
                logger.info(f"[DRY RUN] Would execute arb on: {opp.market_name[:60]}")
                logger.info(f"  YES @ ${opp.yes_ask:.4f} + NO @ ${opp.no_ask:.4f} = ${opp.total_cost:.4f}")
                logger.info(f"  Profit per share: ${opp.profit_per_share:.4f}")
                return True
                
            try:
                shares = min(MAX_POSITION_SIZE / opp.total_cost, 1000)
                
                yes_order = self.client.create_order(OrderArgs(
                    price=opp.yes_ask,
                    size=shares,
                    side=BUY,
                    token_id=opp.yes_token_id
                ))
                self.client.post_order(yes_order)
                
                no_order = self.client.create_order(OrderArgs(
                    price=opp.no_ask,
                    size=shares,
                    side=BUY,
                    token_id=opp.no_token_id
                ))
                self.client.post_order(no_order)
                
                profit = shares * opp.profit_per_share
                self.total_profit += profit
                
                logger.info(f"Executed arb: {opp.market_name[:50]}")
                logger.info(f"  Bought {shares:.2f} shares, Profit: ${profit:.4f}")
                return True
                
            except Exception as e:
                logger.error(f"Failed to execute arb: {e}")
                return False

        def scan_markets(self, markets: list) -> list:
            opportunities = []
            for market in markets:
                opp = self.check_arbitrage(market)
                if opp:
                    opportunities.append(opp)
                    self.opportunities_found += 1
            return opportunities

        def run(self, tags: Optional[list] = None):
            logger.info("=" * 60)
            logger.info("Polymarket Arbitrage Bot Starting")
            logger.info(f"  Min spread: ${MIN_SPREAD}")
            logger.info(f"  Max position: ${MAX_POSITION_SIZE}")
            logger.info(f"  Poll interval: {POLL_INTERVAL}s")
            logger.info(f"  Dry run: {DRY_RUN}")
            logger.info("=" * 60)
            
            if not tags:
                tags = ["esports", "gaming", "league-of-legends", "dota", "csgo"]
            
            while True:
                try:
                    all_markets = []
                    for tag in tags:
                        markets = self.get_active_markets(tag=tag)
                        all_markets.extend(markets)
                    
                    all_markets.extend(self.get_active_markets())
                    
                    seen = set()
                    unique_markets = []
                    for m in all_markets:
                        cid = m.get("condition_id")
                        if cid and cid not in seen:
                            seen.add(cid)
                            unique_markets.append(m)
                    
                    logger.info(f"Scanning {len(unique_markets)} unique markets...")
                    opportunities = self.scan_markets(unique_markets)
                    
                    if opportunities:
                        logger.info(f"Found {len(opportunities)} arbitrage opportunities!")
                        for opp in opportunities:
                            self.execute_arbitrage(opp)
                    
                    if self.opportunities_found > 0:
                        logger.info(f"Stats: {self.opportunities_found} opps, ${self.total_profit:.2f} profit")
                    
                    time.sleep(POLL_INTERVAL)
                    
                except KeyboardInterrupt:
                    logger.info("Shutting down...")
                    break
                except Exception as e:
                    logger.error(f"Error in main loop: {e}")
                    time.sleep(5)


    if __name__ == "__main__":
        bot = PolymarketArbBot()
        bot.run()
